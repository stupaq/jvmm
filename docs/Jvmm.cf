-- Jvmm : BNF syntax specification --
-------------------------------------

-- There are 2 shift/reduce conflicts
-- SIf. | SIfElse. -- tested in examples_good/conflict001.jv
-- SAssignArr. | EAccessArr. -- tested in examples_good/conflict002.jv
-- There is 1 reduce/reduce conflict
-- TUser. | any other type label -- tested everywhere
-- Labels prefixed with "Pn_" are prunned in subsequent phases
-- Note the ugly trick with coercion 0 for OpBin, this makes 2 (+) 3 * 4 a
-- parse error. Without this trick one can promote binary operator 2 (+) 3 * 4 =
-- (2 + 3) * 4, we don't really like that.

-- programs --
--------------

entrypoints P_Prog;

P_Prog.     P_Prog ::= [P_DefGlobal];
separator nonempty P_DefGlobal "";

P_GlobFunc. P_DefGlobal ::= P_DefFunc;

P_GlobClass.P_DefGlobal ::= P_DefClass;

-- blocks --
------------

internal    Local. Stmt ::=  "{" [Stmt] ";" [Stmt] "}";

internal    Global. Stmt ::= "global" "{" [Stmt] "}";

P_Block.    P_Block ::= "{" [Stmt] "}";
separator Stmt "";

-- declarations/definitions --
------------------------------

internal    SDefClass.Stmt ::= "class" Ident Stmt;

internal    SDefFunc. Stmt ::= Type Ident "(" [Stmt] ")" "throws" [Type] Stmt;

internal    SDeclVar. Stmt ::= Type Ident ";";

P_Arg.      P_Arg ::= Type Ident;
separator P_Arg ",";

P_DefFunc.  P_DefFunc ::= Type Ident "(" [P_Arg] ")" P_FunExcepts P_Block;

P_Excepts.  P_FunExcepts ::= "throws" [Type];
separator nonempty Type ",";

P_NoExcept. P_FunExcepts ::= ;

P_SDeclVar. Stmt ::= Type [P_Item] ";";
separator nonempty P_Item ",";

P_NoInit.   P_Item ::= Ident;

P_Init.     P_Item ::= Ident "=" Expr;

P_DefClass. P_DefClass ::= "class" Ident "{" [P_Member] "}";
separator nonempty P_Member ";";
terminator P_Member ";";

P_Field.    P_Member ::= Type Ident;

-- statements --
----------------

P_SBlock.   Stmt ::= P_Block;

P_SAssignOp. Stmt ::= Ident OpAssign Expr  ";";

P_SAssignOpArr. Stmt ::= Ident "[" Expr "]" OpAssign Expr  ";";

P_SAssignOpFld. Stmt ::= Ident "." Ident OpAssign Expr  ";";

P_SPostInc. Stmt ::= Ident "++" ";";

P_SPostDec. Stmt ::= Ident "--" ";";

SEmpty.     Stmt ::= ";";

SAssign.    Stmt ::= Ident "=" Expr  ";";

SAssignArr. Stmt ::= Ident "[" Expr "]" "=" Expr  ";";

SAssignFld. Stmt ::= Ident "." Ident "=" Expr  ";";

SReturn.    Stmt ::= "return" Expr ";";

SReturnV.   Stmt ::= "return" ";";

SIf.        Stmt ::= "if" "(" Expr ")" Stmt;

SIfElse.    Stmt ::= "if" "(" Expr ")" Stmt "else" Stmt;

SWhile.     Stmt ::= "while" "(" Expr ")" Stmt;

P_SForeach. Stmt ::= "for" "(" Type Ident ":" Expr ")" Stmt;

SExpr.      Stmt ::= Expr ";";

SThrow.     Stmt ::= "throw" Expr ";";

STryCatch.  Stmt ::= "try" Stmt "catch" "(" Type Ident ")" Stmt;

-- types --
-----------

internal    TFunc. Type ::= Type "(" [Type] ")" "throws" [Type];

internal    TUnknown. Type ::= "unknown";

internal    TNull. Type ::= "null";

TArray.     Type1 ::= Type "[]";

TInt.       Type ::= "int";

TString.    Type ::= "String";

TChar.      Type ::= "char";

TBool.      Type ::= "boolean";

TVoid.      Type ::= "void";

TUser.      Type ::= Ident;

TObject.    Type ::= "Object";

coercions Type 1;

-- expressions --
-----------------

internal    EBinaryT. Expr ::= Type "=| (" OpBin ") (" Expr ") (" Expr ")";

internal    EUnaryT. Expr ::= Type "=| (" OpUn ") (" Expr ")";

EVar.       Expr8 ::= Ident;

ELitInt.    Expr8 ::= Integer;

ELitTrue.   Expr8 ::= "true";

ELitFalse.  Expr8 ::= "false";

ELitString. Expr8 ::= String;

ELitChar.   Expr8 ::= Char;

ENull.      Expr8 ::= "null";

EAccessArr. Expr7 ::= Expr8 "[" Expr "]";

EAccessFn.  Expr7 ::= Expr8 "." Ident "(" [Expr] ")";

EAccessVar. Expr7 ::= Expr8 "." Ident;

EApp.       Expr7 ::= Ident "(" [Expr] ")";

ENewArr.    Expr6 ::= "new" Type "[" Expr "]";

ENewObj.    Expr6 ::= "new" Type;

P_ENeg.     Expr5 ::= "-" Expr5;

P_ENot.     Expr5 ::= "!" Expr5;

P_EMul.     Expr4 ::= Expr4 OpBin4 Expr5 ;

P_EAdd.     Expr3 ::= Expr3 OpBin3 Expr4 ;

P_ERel.     Expr2 ::= Expr2 OpBin2 Expr3 ;

P_EAnd.     Expr1 ::= Expr2 OpBin1 Expr1 ;

P_EOr.      Expr ::= Expr1 OpBin Expr ;

coercions Expr 8;

separator Expr ",";

-- operators --
---------------

internal    Neg. OpUn ::= "-";

internal    Not. OpUn ::= "!";

APlus.      OpAssign ::= "+=";

AMinus.     OpAssign ::= "-=";

ATimes.     OpAssign ::= "*=";

ADiv.       OpAssign ::= "/=";

AMod.       OpAssign ::= "%=";

Times.      OpBin4 ::= "*";

Div.        OpBin4 ::= "/";

Mod.        OpBin4 ::= "%";

Plus.       OpBin3 ::= "+";

Minus.      OpBin3 ::= "-";

LTH.        OpBin2 ::= "<";

LEQ.        OpBin2 ::= "<=";

GTH.        OpBin2 ::= ">";

GEQ.        OpBin2 ::= ">=";

EQU.        OpBin2 ::= "==";

NEQ.        OpBin2 ::= "!=";

And.        OpBin1 ::= "&&";

Or.         OpBin ::= "||";

-- disable parentheses promotion
coercions OpBin 0;

-- tokens --
------------

-- comments --
--------------

comment  "//";

comment  "/*" "*/";

