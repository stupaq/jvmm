module Syntax.SkelJvmm where

-- Haskell module generated by the BNF converter

import Syntax.AbsJvmm
import Syntax.ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transSemicolon :: Semicolon -> Result
transSemicolon x = case x of
  Semicolon str  -> failure x


transLeftBrace :: LeftBrace -> Result
transLeftBrace x = case x of
  LeftBrace str  -> failure x


transRightBrace :: RightBrace -> Result
transRightBrace x = case x of
  RightBrace str  -> failure x


transProgram :: Program -> Result
transProgram x = case x of
  Program definitions  -> failure x


transDefinition :: Definition -> Result
transDefinition x = case x of
  DFunction function  -> failure x
  DClass class'  -> failure x


transFunction :: Function -> Result
transFunction x = case x of
  Function typebasic id arguments exceptions leftbrace stmts rightbrace  -> failure x


transArgument :: Argument -> Result
transArgument x = case x of
  Argument typebasic id  -> failure x


transExceptions :: Exceptions -> Result
transExceptions x = case x of
  NoExceptions  -> failure x
  Exceptions typecomposeds  -> failure x


transClass :: Class -> Result
transClass x = case x of
  Class id extends leftbrace members rightbrace  -> failure x


transMember :: Member -> Result
transMember x = case x of
  FieldsList typebasic fields semicolon  -> failure x
  Method function  -> failure x


transField :: Field -> Result
transField x = case x of
  Field id  -> failure x


transExtends :: Extends -> Result
transExtends x = case x of
  SuperClass typecomposed  -> failure x
  SuperObject  -> failure x


transTypeBasic :: TypeBasic -> Result
transTypeBasic x = case x of
  TComposed typecomposed  -> failure x
  TPrimitive typeprimitive  -> failure x


transTypeComposed :: TypeComposed -> Result
transTypeComposed x = case x of
  TObject  -> failure x
  TUser id  -> failure x
  TArray typebasic  -> failure x
  TString  -> failure x


transTypePrimitive :: TypePrimitive -> Result
transTypePrimitive x = case x of
  TInt  -> failure x
  TChar  -> failure x
  TBool  -> failure x
  TVoid  -> failure x


transStmt :: Stmt -> Result
transStmt x = case x of
  SThrow expr semicolon  -> failure x
  STryCatch stmt1 typecomposed2 id3 stmt4  -> failure x
  SBlock leftbrace stmts rightbrace  -> failure x
  SEmpty semicolon  -> failure x
  SDeclVar typebasic items semicolon  -> failure x
  SAssign expr1 expr2 semicolon3  -> failure x
  SAssignOp expr1 assignop2 expr3 semicolon4  -> failure x
  SPostInc expr semicolon  -> failure x
  SPostDec expr semicolon  -> failure x
  SReturn expr semicolon  -> failure x
  SReturnV semicolon  -> failure x
  SIf expr stmt  -> failure x
  SIfElse expr stmt1 stmt2  -> failure x
  SWhile expr stmt  -> failure x
  SForeach typebasic id expr stmt  -> failure x
  SExpr expr semicolon  -> failure x


transItem :: Item -> Result
transItem x = case x of
  NoInit id  -> failure x
  Init id expr  -> failure x


transExpr :: Expr -> Result
transExpr x = case x of
  EVar id  -> failure x
  ELitInt n  -> failure x
  ELitTrue  -> failure x
  ELitFalse  -> failure x
  EString str  -> failure x
  EThis  -> failure x
  ENull  -> failure x
  ENullT typecomposed  -> failure x
  ELitChar c  -> failure x
  EArray expr1 expr2  -> failure x
  EField expr id  -> failure x
  EMethod expr id exprs  -> failure x
  ENewObject typecomposed  -> failure x
  ENewArray typebasic expr  -> failure x
  EApp id exprs  -> failure x
  ENeg expr  -> failure x
  ENot expr  -> failure x
  EMul expr1 mulop2 expr3  -> failure x
  EAdd expr1 addop2 expr3  -> failure x
  ERel expr1 relop2 expr3  -> failure x
  EAnd expr1 expr2  -> failure x
  EOr expr1 expr2  -> failure x


transAssignOp :: AssignOp -> Result
transAssignOp x = case x of
  APlus  -> failure x
  AMinus  -> failure x
  ATimes  -> failure x
  ADiv  -> failure x
  AMod  -> failure x


transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus  -> failure x
  Minus  -> failure x


transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times  -> failure x
  Div  -> failure x
  Mod  -> failure x


transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH  -> failure x
  LEQ  -> failure x
  GTH  -> failure x
  GEQ  -> failure x
  EQU  -> failure x
  NEQ  -> failure x



